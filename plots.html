<!DOCTYPE html>
<html lang="en">
<head>
	<meta id="meta" name="viewport" content="width=device-width, initial-scale=1.0" />
	<title> BD Economics | Interactive Charts </title>
	<link rel="stylesheet" href="style.css">
	<link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato:900" rel="stylesheet">
	<script src="https://use.fontawesome.com/8f99c5621e.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
	<meta charset="UTF-8">
	<meta name="description" content="Interactive economic charts with hover tooltips showing time series data.">
	<meta name="keywords" content="interactive charts, economic data visualization, time series charts, US economy charts">
	<meta name="author" content="Brian Dew">
	<link rel="canonical" href="https://www.bd-econ.com/plots.html">
	<!-- Open Graph -->
	<meta property="og:title" content="BD Economics | Interactive Charts">
	<meta property="og:description" content="Interactive economic charts with hover tooltips showing time series data.">
	<meta property="og:url" content="https://www.bd-econ.com/plots.html">
	<meta property="og:type" content="website">
	<meta property="og:image" content="https://www.bd-econ.com/images/01_bdlogo.png">
	<!-- Twitter Card -->
	<meta name="twitter:card" content="summary">
	<meta name="twitter:title" content="BD Economics | Interactive Charts">
	<meta name="twitter:description" content="Interactive economic charts with hover tooltips showing time series data.">
	<meta name="twitter:image" content="https://www.bd-econ.com/images/01_bdlogo.png">
	<link rel="apple-touch-icon" sizes="57x57" href="favicon/apple-icon-57x57.png">
	<link rel="apple-touch-icon" sizes="60x60" href="favicon/apple-icon-60x60.png">
	<link rel="apple-touch-icon" sizes="72x72" href="favicon/apple-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="76x76" href="favicon/apple-icon-76x76.png">
	<link rel="apple-touch-icon" sizes="114x114" href="favicon/apple-icon-114x114.png">
	<link rel="apple-touch-icon" sizes="120x120" href="favicon/apple-icon-120x120.png">
	<link rel="apple-touch-icon" sizes="144x144" href="favicon/apple-icon-144x144.png">
	<link rel="apple-touch-icon" sizes="152x152" href="favicon/apple-icon-152x152.png">
	<link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-icon-180x180.png">
	<link rel="icon" type="image/png" sizes="192x192"  href="favicon/android-icon-192x192.png">
	<link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="96x96" href="favicon/favicon-96x96.png">
	<link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">
	<link rel="manifest" href="favicon/manifest.json">
	<meta name="msapplication-TileColor" content="#ffffff">
	<meta name="msapplication-TileImage" content="favicon/ms-icon-144x144.png">
	<meta name="theme-color" content="#ffffff">

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PGVF5S620Y"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-PGVF5S620Y');
</script>

<style>
	.chart-container {
		position: relative;
		width: 100%;
		max-width: 400px;
		margin: 1rem auto;
		background: #fff;
		box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
	}
	.chart-header {
		background-color: var(--color-card-blue);
		color: white;
		padding: 6px 10px 5px 10px;
	}
	.chart-header h4 {
		font-family: 'Montserrat', sans-serif;
		font-size: 15px;
		margin: 0;
		font-weight: 600;
		color: white;
	}
	.chart-subtitle {
		font-size: 10px;
		font-style: italic;
		color: #6a6a6a;
		margin: 0 0 4px 0;
	}
	.chart-body {
		padding: 4px 10px 6px 10px;
	}
	.chart-footer {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 0 10px 7px 10px;
	}
	.chart-source {
		font-size: 9px;
		color: var(--color-text-gray);
		text-align: right;
		margin: 0;
		font-style: italic;
	}
	.chart-selector {
		max-width: 400px;
		margin: 0 auto 1rem auto;
		font-family: 'Montserrat', sans-serif;
		font-size: 14px;
	}
	.chart-selector label {
		margin-right: 8px;
		color: #333;
	}
	.chart-selector select {
		font-family: 'Montserrat', sans-serif;
		font-size: 14px;
		padding: 6px 12px;
		border: 1px solid #ccc;
		border-radius: 4px;
		background: white;
		cursor: pointer;
	}
	.chart-selector select:hover {
		border-color: var(--color-card-blue);
	}
	.chart-filter {
		font-size: 9px;
		color: #6a6a6a;
		margin: 0;
		visibility: hidden;
	}
	.chart-filter a {
		color: var(--color-card-blue);
		text-decoration: none;
		cursor: pointer;
	}
	.chart-filter a:hover {
		text-decoration: underline;
	}
	.chart-legend {
		display: flex;
		justify-content: center;
		gap: 16px;
		margin-bottom: 6px;
		font-size: 10px;
		font-family: 'Montserrat', sans-serif;
	}
	.chart-legend-item {
		display: flex;
		align-items: center;
		gap: 4px;
		cursor: pointer;
		color: #333;
	}
	.chart-legend-item:hover {
		opacity: 0.8;
	}
	.chart-legend-item.hidden {
		opacity: 0.4;
		text-decoration: line-through;
	}
	.chart-legend-box {
		width: 14px;
		height: 3px;
		border-radius: 1px;
	}
	/* Dual bar chart styles */
	.dual-bar-container {
		display: flex;
		gap: 10px;
	}
	.dual-bar-panel {
		flex: 1;
		min-width: 0;
	}
	.dual-bar-panel h5 {
		font-size: 10px;
		color: #6a6a6a;
		margin: 0 0 6px 0;
		text-align: center;
		font-family: 'Montserrat', sans-serif;
		font-weight: 600;
	}
	.hbar-rows-container {
		position: relative;
	}
	.hbar-zero-line {
		position: absolute;
		left: 50%;
		top: 0;
		bottom: 0;
		width: 1px;
		background: #666;
	}
	.hbar-row {
		display: flex;
		align-items: center;
		margin-bottom: 7px;
		font-size: 9px;
		font-family: Tahoma, Verdana, sans-serif;
		height: 22px;
	}
	.hbar-row:last-child {
		margin-bottom: 0;
	}
	.hbar-left {
		display: flex;
		justify-content: flex-end;
		align-items: center;
		height: 20px;
	}
	.hbar-right {
		display: flex;
		justify-content: flex-start;
		align-items: center;
		height: 20px;
	}
	.hbar-fill {
		height: 100%;
		background: var(--color-card-red);
	}
	.hbar-label {
		color: #333;
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
		padding: 0 3px;
	}
	.hbar-value {
		font-size: 9px;
		color: #333;
		white-space: nowrap;
		padding: 0 2px;
	}
</style>

</head>
<body>
	<nav>
		<ul class="ul_nav" id="menu">
			<li class="nav_main"> <a href="index.html">BD Economics</a> </li>
			<li><a href="about.html">About</a> </li>
			<li><a href="http://briandew.wordpress.com">Blog</a> </li>
			<li><a href="python.html">Guides &darr;</a>
				<ul class="hidden">
					<li><a href="imfapi1.html">IMF API</a></li>
					<li><a href="blsapi.html">BLS API</a></li>
					<li><a href="beaapi.html">BEA API</a></li>
					<li><a href="censusapi.html">Census API</a></li>
					<li><a href="treasuryapi.html">Treasury API</a></li>
					<li><a href="cps.html">CPS Microdata</a></li>
			</ul>
			</li>
		<li>
			<a href="chartbook.html">Reports &darr;</a>
			<ul class="hidden">
				<li><a href="chartbook.pdf">US Chartbook (PDF)</a></li>
			</ul>
			<li class="icon"> <a href="javascript:void(0);"
				style="font-size:15px;" onclick="responsiveNav()">&#9776;</a>
			</li>
		</ul>
	</nav>

	<header>
	<h3>Interactive Charts</h3>
	</header>
	<section>
	<article>
	<p>Interactive visualizations of economic time series data. Hover over points to see values.</p>
	</article>

	<article>
		<div class="chart-selector">
			<label for="dataset-select">Select chart:</label>
			<select id="dataset-select"></select>
		</div>
		<div class="chart-container">
			<div class="chart-header">
				<h4 id="chart-title">M2 Money Supply / GDP</h4>
			</div>
			<div class="chart-body">
				<p class="chart-subtitle" id="chart-subtitle">index, 1988=1</p>
				<div class="chart-legend" id="chart-legend"></div>
				<canvas id="lineChart"></canvas>
			</div>
			<div class="chart-footer">
				<p class="chart-filter" id="chart-filter"><a onclick="toggleTimeRange()">Recent 3 years</a></p>
				<p class="chart-source" id="chart-source">Source: Federal Reserve, BEA</p>
			</div>
		</div>
	</article>

	</section>

	<footer>
		<div class="footer_left">
			<p>January 12, 2026<br> by Brian Dew</p>
		</div>
		<div class="footer_right">
			<a href="https://github.com/bdecon/">
				<button class="button_sm"><i class="fa fa-github"></i></button>
			</a>
			<a href="https://www.linkedin.com/in/brian-dew-5788a386/">
				<button class="button_sm"><i class="fa fa-linkedin"></i></button>
			</a>
			<a href="https://twitter.com/bd_econ">
				<button class="button_sm"><i class="fa fa-twitter"></i></button>
			</a>
			<a href="https://briandew.wordpress.com/">
				<button class="button_sm"><i class="fa fa-wordpress"></i></button>
			</a>
		</div>
	</footer>
	<script>
		function responsiveNav() {
			var x = document.getElementById("menu");
			if (x.className === "ul_nav") {
				x.className += " responsive";
			} else {
				x.className = "ul_nav";
			}
		}
	</script>

	<script>
		// Global state
		let manifest = null;
		let chart = null;
		let currentDateFormat = null;
		let fullData = null;
		let isFilteredView = false;
		let currentConfig = null;

		// Color mapping to CSS variables
		const colorMap = {
			blue: {
				border: getComputedStyle(document.documentElement).getPropertyValue('--color-card-blue').trim() || '#3441de',
				background: 'rgba(52, 65, 222, 0.08)',
				backgroundStrong: 'rgba(52, 65, 222, 0.3)'
			},
			green: {
				border: getComputedStyle(document.documentElement).getPropertyValue('--color-card-green').trim() || '#27AE60',
				background: 'rgba(39, 174, 96, 0.08)',
				backgroundStrong: 'rgba(39, 174, 96, 0.3)'
			},
			red: {
				border: getComputedStyle(document.documentElement).getPropertyValue('--color-card-red').trim() || '#FF2F2F',
				background: 'rgba(255, 47, 47, 0.08)',
				backgroundStrong: 'rgba(255, 47, 47, 0.3)'
			},
			orange: {
				border: getComputedStyle(document.documentElement).getPropertyValue('--color-card-orange').trim() || '#FF8700',
				background: 'rgba(255, 135, 0, 0.08)',
				backgroundStrong: 'rgba(255, 135, 0, 0.3)'
			},
			purple: {
				border: getComputedStyle(document.documentElement).getPropertyValue('--color-card-purple').trim() || '#721ce7',
				background: 'rgba(114, 28, 231, 0.08)',
				backgroundStrong: 'rgba(114, 28, 231, 0.3)'
			},
			yellow: {
				border: getComputedStyle(document.documentElement).getPropertyValue('--color-card-yellow').trim() || '#FFC300',
				background: 'rgba(255, 195, 0, 0.08)',
				backgroundStrong: 'rgba(255, 195, 0, 0.3)'
			},
			ltblue: {
				border: getComputedStyle(document.documentElement).getPropertyValue('--color-card-ltblue').trim() || '#1E90FF',
				background: 'rgba(30, 144, 255, 0.08)',
				backgroundStrong: 'rgba(30, 144, 255, 0.3)'
			}
		};

		// Chart type configurations
		function getChartTypeConfig(type, colors, config) {
			const baseDataset = {
				borderColor: colors.border,
				backgroundColor: colors.background,
				borderWidth: 1.5,
				pointRadius: 1,
				pointHoverRadius: 4,
				pointBackgroundColor: colors.border,
				pointHoverBackgroundColor: colors.border
			};

			switch (type) {
				case 'line':
					return {
						type: 'line',
						dataset: {
							...baseDataset,
							fill: config.fill !== false,
							tension: 0.1
						}
					};
				case 'area':
					return {
						type: 'line',
						dataset: {
							...baseDataset,
							fill: true,
							tension: 0.1,
							backgroundColor: colors.backgroundStrong
						}
					};
				case 'bar':
					return {
						type: 'bar',
						dataset: {
							backgroundColor: colors.border,
							borderColor: colors.border,
							borderWidth: 0
						}
					};
				case 'scatter':
					return {
						type: 'scatter',
						dataset: {
							backgroundColor: colors.border,
							borderColor: colors.border,
							pointRadius: 3,
							pointHoverRadius: 5
						}
					};
				default:
					return {
						type: 'line',
						dataset: baseDataset
					};
			}
		}

		// Date formatting based on frequency
		function getDateFormatConfig(dateFormat) {
			switch (dateFormat) {
				case 'monthly':
					return {
						tickCallback: function(value, index) {
							const dateStr = this.getLabelForValue(value);
							return dateStr ? dateStr.substring(0, 4) : '';
						},
						tooltipTitle: function(context) {
							const date = new Date(context[0].label);
							const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
								'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
							return months[date.getUTCMonth()] + ' ' + date.getUTCFullYear();
						},
						lastValueFormat: function(date) {
							const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
								'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
							return [months[date.getUTCMonth()], date.getUTCFullYear()];
						}
					};
				case 'annual':
					return {
						tickCallback: function(value, index) {
							const dateStr = this.getLabelForValue(index);
							return dateStr.substring(0, 4);
						},
						tooltipTitle: function(context) {
							const date = new Date(context[0].label);
							return date.getUTCFullYear().toString();
						},
						lastValueFormat: function(date) {
							return [date.getUTCFullYear()];
						}
					};
				case 'daily':
					return {
						tickCallback: function(value, index) {
							if (index % 30 === 0) {
								const dateStr = this.getLabelForValue(index);
								return dateStr.substring(0, 7);
							}
							return '';
						},
						tooltipTitle: function(context) {
							return context[0].label;
						},
						lastValueFormat: function(date) {
							return [date.toISOString().substring(0, 10)];
						}
					};
				case 'quarterly':
				default:
					return {
						tickCallback: function(value, index) {
							const dateStr = this.getLabelForValue(value);
							return dateStr ? dateStr.substring(0, 4) : '';
						},
						tooltipTitle: function(context) {
							const date = new Date(context[0].label);
							const quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
							return 'Q' + quarter + ' ' + date.getUTCFullYear();
						},
						lastValueFormat: function(date) {
							const quarter = 'Q' + Math.ceil((date.getUTCMonth() + 1) / 3);
							return [quarter, date.getUTCFullYear()];
						}
					};
			}
		}

		// Custom plugin to draw last value label
		const lastValuePlugin = {
			id: 'lastValueLabel',
			afterDraw: function(chart) {
				const config = chart.config._config.datasetConfig;
				const isMultiSeries = config?.series && config.series.length > 1;
				const decimals = config?.decimals ?? 2;
				const ctx = chart.ctx;

				// For multi-series, position labels at actual y-positions (or stack if overlapping)
				if (isMultiSeries) {
					const visibleDatasets = chart.data.datasets
						.map((ds, i) => ({ ds, i }))
						.filter(({ i }) => chart.isDatasetVisible(i));

					if (visibleDatasets.length === 0) return;

					const lastIndex = chart.data.datasets[0].data.length - 1;
					const lastDate = new Date(chart.data.labels[lastIndex]);
					const dateLabels = currentDateFormat
						? currentDateFormat.lastValueFormat(lastDate)
						: ['Q' + Math.ceil((lastDate.getUTCMonth() + 1) / 3), lastDate.getUTCFullYear()];

					// Get x position from first visible dataset's last point
					const firstMeta = chart.getDatasetMeta(visibleDatasets[0].i);
					const xPos = firstMeta.data[lastIndex]?.x;
					if (!xPos) return;

					const x = xPos + 8;

					// Get actual y-positions for each dataset
					const labelData = visibleDatasets.map(({ ds, i }) => {
						const meta = chart.getDatasetMeta(i);
						const lastPoint = meta.data[lastIndex];
						return {
							ds,
							i,
							value: ds.data[lastIndex],
							yPos: lastPoint.y
						};
					});

					// Check for overlap (labels within 25px of each other)
					const sortedByY = [...labelData].sort((a, b) => a.yPos - b.yPos);
					const hasOverlap = sortedByY.length > 1 &&
						sortedByY.some((item, idx) =>
							idx > 0 && Math.abs(item.yPos - sortedByY[idx-1].yPos) < 25
						);

					ctx.save();
					ctx.font = '9px Tahoma, Verdana, sans-serif';
					ctx.textAlign = 'left';

					if (hasOverlap) {
						// Stack labels at top when lines are close together
						ctx.textBaseline = 'top';
						let y = 12;

						// Draw date labels first
						ctx.fillStyle = '#6a6a6a';
						dateLabels.forEach((label) => {
							ctx.fillText(label, x, y);
							y += 11;
						});

						// Sort by value descending so labels match visual line order
						const sortedByValue = [...labelData].sort((a, b) => b.value - a.value);

						// Draw each visible series value with its color
						sortedByValue.forEach(({ ds }) => {
							const valueStr = ds.data[lastIndex].toFixed(decimals);
							ctx.fillStyle = ds.borderColor;
							ctx.fillText(valueStr, x, y);
							y += 11;
						});
					} else {
						// Position labels at actual y-positions when lines are far apart
						ctx.textBaseline = 'middle';

						// Draw date at top
						ctx.fillStyle = '#6a6a6a';
						let dateY = 12;
						dateLabels.forEach((label) => {
							ctx.fillText(label, x, dateY);
							dateY += 11;
						});

						// Draw each value at its actual y position
						labelData.forEach(({ ds, yPos }) => {
							const valueStr = ds.data[lastIndex].toFixed(decimals);
							ctx.fillStyle = ds.borderColor;
							ctx.fillText(valueStr, x, yPos);
						});
					}

					ctx.restore();
				} else {
					// Single series - original behavior
					const dataset = chart.data.datasets[0];
					const meta = chart.getDatasetMeta(0);
					const lastIndex = dataset.data.length - 1;
					const lastPoint = meta.data[lastIndex];

					if (!lastPoint) return;

					const x = lastPoint.x + 8;
					const y = lastPoint.y;

					const lastDate = new Date(chart.data.labels[lastIndex]);
					const valueStr = dataset.data[lastIndex].toFixed(decimals);

					const dateLabels = currentDateFormat
						? currentDateFormat.lastValueFormat(lastDate)
						: ['Q' + Math.ceil((lastDate.getUTCMonth() + 1) / 3), lastDate.getUTCFullYear()];

					ctx.save();
					ctx.font = '9px Tahoma, Verdana, sans-serif';
					ctx.fillStyle = '#6a6a6a';
					ctx.textAlign = 'left';
					ctx.textBaseline = 'middle';

					dateLabels.forEach((label, i) => {
						ctx.fillText(label, x, y - 12 + (i * 12));
					});
					ctx.fillText(valueStr, x, y + (dateLabels.length - 1) * 12);

					ctx.restore();
				}
			}
		};

		// Custom plugin to draw data labels above bars
		const dataLabelsPlugin = {
			id: 'dataLabels',
			afterDatasetsDraw: function(chart) {
				const config = chart.config._config.datasetConfig;
				if (!config?.showDataLabels) return;

				const ctx = chart.ctx;
				const meta = chart.getDatasetMeta(0);
				const decimals = config.decimals ?? 0;

				ctx.save();
				ctx.font = '9px Tahoma, Verdana, sans-serif';
				ctx.fillStyle = '#333';
				ctx.textAlign = 'center';
				ctx.textBaseline = 'bottom';

				meta.data.forEach((bar, index) => {
					const value = chart.data.datasets[0].data[index];
					ctx.fillText(value.toFixed(decimals), bar.x, bar.y - 4);
				});

				ctx.restore();
			}
		};

		// Render dual horizontal bar chart
		function renderDualBarChart(config, data) {
			const top5 = data.slice(0, 5);
			const bottom5 = data.slice(-5);

			// Shared scale: use max absolute value across ALL data
			const maxVal = Math.max(...data.map(d => Math.abs(d.value)));
			const minVal = Math.min(...data.map(d => d.value));

			// Calculate left side width based on whether there are negative values
			// Left side needs space for: negative bars OR positive labels
			const hasNegative = minVal < 0;
			const negBarMax = hasNegative ? Math.abs(minVal) / maxVal * 50 : 0;
			const leftWidth = 50; // Fixed 50% for left side (labels or neg bars)
			const rightWidth = 50; // Fixed 50% for right side (pos bars or labels)

			function renderPanel(items, title) {
				const rows = items.map(d => {
					const valueStr = d.value.toFixed(2);
					const barPct = (Math.abs(d.value) / maxVal) * 100;

					let leftContent, rightContent;

					if (d.value >= 0) {
						// Positive: label on left (right-aligned), bar+value on right
						leftContent = `<span class="hbar-label" title="${d.name}">${d.name}</span>`;
						rightContent = `<div class="hbar-fill" style="width: ${barPct}%;"></div><span class="hbar-value">${valueStr}</span>`;
					} else {
						// Negative: value+bar on left, label on right
						leftContent = `<span class="hbar-value">${valueStr}</span><div class="hbar-fill" style="width: ${barPct}%;"></div>`;
						rightContent = `<span class="hbar-label" title="${d.name}">${d.name}</span>`;
					}

					return `
					<div class="hbar-row">
						<div class="hbar-left" style="width: ${leftWidth}%;">${leftContent}</div>
						<div class="hbar-right" style="width: ${rightWidth}%;">${rightContent}</div>
					</div>`;
				}).join('');

				return `<div class="dual-bar-panel">
					<h5>${title}</h5>
					<div class="hbar-rows-container">
						<div class="hbar-zero-line"></div>
						${rows}
					</div>
				</div>`;
			}

			return `<div class="dual-bar-container">
				${renderPanel(top5, 'Top 5')}
				${renderPanel(bottom5, 'Bottom 5')}
			</div>`;
		}

		// Show error message
		function showError(message) {
			document.getElementById('chart-title').textContent = 'Error';
			document.getElementById('chart-subtitle').textContent = message;
			document.getElementById('chart-source').textContent = '';
			if (chart) {
				chart.destroy();
				chart = null;
			}
		}

		// Filter data to last N years
		function filterToLastYears(data, years) {
			const cutoffDate = new Date();
			cutoffDate.setFullYear(cutoffDate.getFullYear() - years);
			return data.filter(d => new Date(d.date) >= cutoffDate);
		}

		// Tick callback for filtered view (shows month/quarter + year)
		function getFilteredTickCallback(dateFormat) {
			const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
				'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

			return function(value, index) {
				const dateStr = this.getLabelForValue(value);
				if (!dateStr) return '';
				const date = new Date(dateStr);
				const month = date.getUTCMonth();
				const year = date.getUTCFullYear();

				if (dateFormat === 'monthly') {
					return months[month] + ' ' + year;
				} else if (dateFormat === 'quarterly') {
					const quarter = Math.floor(month / 3) + 1;
					return 'Q' + quarter + ' ' + year;
				} else if (dateFormat === 'annual') {
					return year.toString();
				} else {
					return months[month] + ' ' + year;
				}
			};
		}

		// Toggle between full data and last 3 years
		function toggleTimeRange() {
			if (!chart || !fullData) return;

			const filterLink = document.getElementById('chart-filter').querySelector('a');
			const dateFormat = currentConfig?.dateFormat || 'quarterly';
			const isMultiSeries = currentConfig?.series && currentConfig.series.length > 1;

			if (isFilteredView) {
				// Show all data
				chart.data.labels = fullData.map(d => d.date);
				if (isMultiSeries) {
					chart.data.datasets.forEach((ds, i) => {
						ds.data = fullData.map(d => d.values[i]);
					});
				} else {
					chart.data.datasets[0].data = fullData.map(d => d.value);
				}
				chart.options.scales.x.ticks.callback = currentDateFormat.tickCallback;
				filterLink.textContent = 'Recent 3 years';
				isFilteredView = false;
			} else {
				// Filter to last 3 years
				const filtered = filterToLastYears(fullData, 3);
				chart.data.labels = filtered.map(d => d.date);
				if (isMultiSeries) {
					chart.data.datasets.forEach((ds, i) => {
						ds.data = filtered.map(d => d.values[i]);
					});
				} else {
					chart.data.datasets[0].data = filtered.map(d => d.value);
				}
				chart.options.scales.x.ticks.callback = getFilteredTickCallback(dateFormat);
				filterLink.textContent = 'Full history';
				isFilteredView = true;
			}

			chart.update();
		}

		// Render legend for multi-series charts
		function renderLegend(config) {
			const legendContainer = document.getElementById('chart-legend');

			if (!config.series || config.series.length <= 1) {
				legendContainer.innerHTML = '';
				legendContainer.style.display = 'none';
				return;
			}

			legendContainer.style.display = 'flex';
			legendContainer.innerHTML = config.series.map((s, i) => {
				const colors = colorMap[s.color || config.color || 'blue'];
				return `
					<div class="chart-legend-item" data-index="${i}">
						<span class="chart-legend-box" style="background-color: ${colors.border}"></span>
						<span>${s.label}</span>
					</div>
				`;
			}).join('');

			// Add click handlers
			legendContainer.querySelectorAll('.chart-legend-item').forEach(item => {
				item.addEventListener('click', () => {
					const index = parseInt(item.dataset.index);
					const isVisible = chart.isDatasetVisible(index);
					chart.setDatasetVisibility(index, !isVisible);
					item.classList.toggle('hidden', isVisible);
					chart.update();
				});
			});
		}

		// Populate dropdown with optional grouping
		function populateDropdown() {
			const select = document.getElementById('dataset-select');
			select.innerHTML = '';

			const charts = manifest.charts;
			const hasCategories = charts.some(d => d.category);

			if (hasCategories) {
				// Group by category
				const groups = {};
				charts.forEach(ds => {
					const cat = ds.category || 'Other';
					if (!groups[cat]) groups[cat] = [];
					groups[cat].push(ds);
				});

				Object.keys(groups).sort().forEach(category => {
					const optgroup = document.createElement('optgroup');
					optgroup.label = category;
					groups[category].forEach(ds => {
						const option = document.createElement('option');
						option.value = ds.id;
						option.textContent = ds.title;
						optgroup.appendChild(option);
					});
					select.appendChild(optgroup);
				});
			} else {
				// Flat list
				charts.forEach(ds => {
					const option = document.createElement('option');
					option.value = ds.id;
					option.textContent = ds.title;
					select.appendChild(option);
				});
			}
		}

		// Load and display chart for given dataset
		async function loadChart(datasetId) {
			const config = manifest.charts.find(d => d.id === datasetId);
			if (!config) {
				showError('Dataset not found: ' + datasetId);
				return;
			}

			// Update URL hash for sharing
			window.history.replaceState(null, '', '#' + datasetId);

			// Update DOM elements
			document.getElementById('chart-title').textContent = config.title;
			document.getElementById('chart-subtitle').textContent = config.subtitle || '';
			document.getElementById('chart-source').textContent = 'Source: ' + config.source;

			// Update header color (use first series color for multi-series)
			const header = document.querySelector('.chart-header');
			const isMultiSeries = config.series && config.series.length > 1;
			const headerColor = isMultiSeries
				? colorMap[config.series[0].color || 'blue']
				: colorMap[config.color || 'blue'];
			header.style.backgroundColor = headerColor.border;

			try {
				const response = await fetch(config.file);
				if (!response.ok) {
					throw new Error('Failed to load ' + config.file);
				}
				const csv = await response.text();

				// Parse CSV - handle multi-series differently
				const lines = csv.trim().split('\n');
				let data;
				if (isMultiSeries) {
					data = lines.slice(1).map(line => {
						const parts = line.split(',');
						return {
							date: parts[0],
							values: parts.slice(1).map(v => parseFloat(v))
						};
					});
				} else {
					data = lines.slice(1).map(line => {
						const [date, value] = line.split(',');
						return { date, value: parseFloat(value) };
					});
				}

				// Store full data for filtering and reset view state
				fullData = data;
				isFilteredView = false;
				currentConfig = config;

				// Show/hide filter link (only for time series charts)
				const filterEl = document.getElementById('chart-filter');
				if (config.timeSeries !== false) {
					filterEl.style.visibility = 'visible';
					filterEl.querySelector('a').textContent = 'Recent 3 years';
				} else {
					filterEl.style.visibility = 'hidden';
				}

				// Destroy existing chart
				if (chart) {
					chart.destroy();
					chart = null;
				}

				// Handle dual bar chart type
				if (config.type === 'dualBar') {
					const dualData = lines.slice(1).map(line => {
						const parts = line.split(',');
						return { name: parts[0], value: parseFloat(parts[1]) };
					});

					// Hide canvas, show custom chart
					document.getElementById('lineChart').style.display = 'none';
					document.getElementById('chart-legend').style.display = 'none';
					let customContainer = document.getElementById('custom-chart');
					if (!customContainer) {
						customContainer = document.createElement('div');
						customContainer.id = 'custom-chart';
						document.querySelector('.chart-body').appendChild(customContainer);
					}
					customContainer.style.display = 'block';
					customContainer.innerHTML = renderDualBarChart(config, dualData);
					return;
				}

				// Show canvas for regular charts, hide custom container
				document.getElementById('lineChart').style.display = 'block';
				const customContainer = document.getElementById('custom-chart');
				if (customContainer) {
					customContainer.style.display = 'none';
				}

				// Get configurations
				currentDateFormat = getDateFormatConfig(config.dateFormat || 'quarterly');
				const ctx = document.getElementById('lineChart').getContext('2d');

				// Build datasets based on single vs multi-series
				let datasets;
				let chartType = config.type || 'line';
				if (isMultiSeries) {
					datasets = config.series.map((s, i) => {
						const seriesColors = colorMap[s.color || config.color || 'blue'];
						return {
							label: s.label,
							data: data.map(d => d.values[i]),
							borderColor: seriesColors.border,
							backgroundColor: seriesColors.background,
							pointBackgroundColor: seriesColors.border,
							pointHoverBackgroundColor: seriesColors.border,
							borderWidth: 1.5,
							pointRadius: 1,
							pointHoverRadius: 4,
							fill: false,
							tension: 0.1
						};
					});
				} else {
					const colors = colorMap[config.color || 'blue'];
					const typeConfig = getChartTypeConfig(config.type || 'line', colors, config);
					chartType = typeConfig.type;
					datasets = [{
						label: config.tooltipLabel || config.title,
						data: data.map(d => d.value),
						...typeConfig.dataset
					}];
				}

				chart = new Chart(ctx, {
					type: chartType,
					datasetConfig: config,
					data: {
						labels: data.map(d => d.date),
						datasets: datasets
					},
					plugins: [
						...(config.timeSeries !== false ? [lastValuePlugin] : []),
						...(config.showDataLabels ? [dataLabelsPlugin] : [])
					],
					options: {
						responsive: true,
						maintainAspectRatio: true,
						layout: {
							padding: {
								right: config.timeSeries !== false ? 36 : 0,
								top: config.timeSeries !== false ? 15 : 0
							}
						},
						interaction: {
							intersect: false,
							mode: 'index'
						},
						plugins: {
							tooltip: {
								enabled: true,
								backgroundColor: 'rgba(75, 75, 75, 0.95)',
								titleFont: { size: 11, family: "'Montserrat', sans-serif" },
								bodyFont: { size: 10, family: "Tahoma, Verdana, sans-serif" },
								padding: 8,
								cornerRadius: 2,
								displayColors: isMultiSeries,
								callbacks: {
									title: config.timeSeries !== false
										? currentDateFormat.tooltipTitle
										: function(context) { return context[0].label; },
									label: function(context) {
										const decimals = config.decimals ?? 2;
										if (isMultiSeries) {
											return context.dataset.label + ': ' + context.parsed.y.toFixed(decimals);
										}
										const label = config.tooltipLabel || config.title;
										return label + ': ' + context.parsed.y.toFixed(decimals);
									}
								}
							},
							legend: { display: false }
						},
						scales: {
							x: {
								type: 'category',
								bounds: 'data',
								grid: { display: false },
								ticks: {
									font: { size: 9, family: "Tahoma, Verdana, sans-serif" },
									color: '#6a6a6a',
									callback: config.timeSeries !== false
										? currentDateFormat.tickCallback
										: function(value, index) { return this.getLabelForValue(index); },
									maxRotation: 0,
									minRotation: 0
								}
							},
							y: {
								grace: '5%',
								border: { display: false },
								grid: { color: 'rgba(0, 0, 0, 0.06)' },
								ticks: {
									font: { size: 9, family: "Tahoma, Verdana, sans-serif" },
									color: '#6a6a6a'
								},
								title: { display: false },
								beginAtZero: config.type === 'bar' || config.beginAtZero || false,
								min: config.yAxisMin ?? undefined,
								max: config.yAxisMax ?? undefined
							}
						}
					}
				});

				// Render legend for multi-series charts
				renderLegend(config);
			} catch (error) {
				console.error('Error loading chart:', error);
				showError(error.message);
			}
		}

		// Initialize application
		async function init() {
			try {
				const response = await fetch('files/charts.json');
				if (!response.ok) {
					throw new Error('Failed to load charts.json');
				}
				manifest = await response.json();

				// Sort by order if present, then by title
				manifest.charts.sort((a, b) => {
					if (a.order !== undefined && b.order !== undefined) {
						return a.order - b.order;
					}
					if (a.order !== undefined) return -1;
					if (b.order !== undefined) return 1;
					return a.title.localeCompare(b.title);
				});

				populateDropdown();

				// Load chart from URL hash or first chart
				const hashId = window.location.hash.slice(1);
				const initialId = hashId && manifest.charts.find(d => d.id === hashId)
					? hashId
					: manifest.charts[0].id;

				document.getElementById('dataset-select').value = initialId;
				loadChart(initialId);

			} catch (error) {
				console.error('Initialization error:', error);
				showError(error.message);
			}
		}

		// Handle dropdown changes
		document.getElementById('dataset-select').addEventListener('change', (e) => {
			loadChart(e.target.value);
		});

		// Initialize on page load
		init();
	</script>
</body>
</html>
